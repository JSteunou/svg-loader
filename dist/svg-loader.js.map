{"version":3,"file":"svg-loader.js","mappings":";;;;;;;;;;AAAa;;AAEb;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;;;;;;;;;AChBa;;AAEb;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;ACxCa;;AAEb;AACA;AACA,qCAAqC,WAAW,GAAG,MAAM;AACzD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0CAA0C,gBAAgB;AAC1D;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEyH;;;;;;;UCvLzH;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;ACNa;;AAEb,QAAQ,yBAAyB,EAAE,mBAAO,CAAC,2DAAY;AACvD,iBAAiB,mBAAO,CAAC,2CAAiB;AAC1C,oBAAoB,mBAAO,CAAC,mDAAqB;AACjD,gBAAgB,mBAAO,CAAC,uCAAe;;AAEvC;AACA;;AAEA;AACA,mCAAmC,IAAI;AACvC,MAAM;;AAEN;AACA;AACA,kDAAkD,IAAI;AACtD,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN,sBAAsB,IAAI;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,4BAA4B,IAAI;AAChC,MAAM;AACN;AACA,2CAA2C,IAAI;AAC/C,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,gDAAgD;;AAE5D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,uEAAuE,eAAe;;AAEtF;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,GAAG,GAAG,eAAe;AAClD;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA,cAAc;;AAEd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,+DAA+D,aAAa;AAC5E;AACA;AACA;AACA;AACA,KAAK;;AAEL,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uDAAuD,+CAA+C;;AAEtG;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gDAAgD,IAAI,aAAa,iBAAiB,GAAG,oBAAoB;AACzG;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,6CAA6C,IAAI;AACjD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,KAAK;AACL","sources":["webpack://external-svg-loader/./lib/counter.js","webpack://external-svg-loader/./lib/css-url-fixer.js","webpack://external-svg-loader/./lib/scope-css.js","webpack://external-svg-loader/./node_modules/idb-keyval/dist/index.js","webpack://external-svg-loader/webpack/bootstrap","webpack://external-svg-loader/webpack/runtime/define property getters","webpack://external-svg-loader/webpack/runtime/hasOwnProperty shorthand","webpack://external-svg-loader/webpack/runtime/make namespace object","webpack://external-svg-loader/./svg-loader.js"],"sourcesContent":["\"use strict\";\n\nlet counter = 0;\n\nmodule.exports = {\n    incr () {\n        return ++counter;\n    },\n\n    decr () {\n        return --counter;\n    },\n\n    curr () {\n        return counter;\n    }\n};","\"use strict\";\n\n/**\n * Handle all SVG references correctly, which can be\n *   a) via attributes: url(#abc)\n *   b) via tags: <use href=\"#abc\" />\n *   c) via css: .class { fill: url(#abc) }\n * @param {object} idMap: Map previous id with the new unique id\n * @param {string} attributeValueOrCSS\n * @param {string} attributeName\n * @returns attribute or css value with correct id\n */\nmodule.exports = (idMap, attributeValueOrCSS, attributeName = \"\") => {\n    const svgRefRegex = /url\\(['\"]?#([\\w:.-]+)['\"]?\\)/g;\n    const urlRefRegex = /#([\\w:.-]+)/g;\n\n    // fill=\"url(#abc)\" -> fill=\"url(#abc_2)\"\n    // Use the unique IDs created previously\n    if (attributeValueOrCSS.match(svgRefRegex)) {\n        attributeValueOrCSS = attributeValueOrCSS.replace(svgRefRegex, function (g0, g1) {\n            if (!idMap[g1]) {\n                return g0;\n            }\n            return `url(#${idMap[g1]})`;\n        });\n    }\n\n    // <use href=\"#X\" -> <use href=\"#X_23\"\n    // Use the unique IDs created previously\n    if ([\"href\", \"xlink:href\"].includes(attributeName)) {\n        if (attributeValueOrCSS.match(urlRefRegex)) {\n            attributeValueOrCSS = attributeValueOrCSS.replace(urlRefRegex, function (g0, g1) {\n                if (!idMap[g1]) {\n                    return g0;\n                }\n                return `#${idMap[g1]}`;\n            });\n        }\n    }\n    return attributeValueOrCSS;\n};\n","\"use strict\";\n\n// Source: https://github.com/thomaspark/scoper\nmodule.exports = (css, prefix, idMap) => {\n    const re = new RegExp(\"([^\\r\\n,{}]+)(,(?=[^}]*{)|\\s*{)\", \"g\");\n    css = css.replace(re, function (g0, g1, g2) {\n\n        if (g1.match(/^\\s*(@media|@.*keyframes|to|from|@font-face|1?[0-9]?[0-9])/)) {\n            return g1 + g2;\n        }\n\n        const idRegex = /#(\\w+)/;\n        const match = g1.match(idRegex);\n\n        if (match && idMap[match[1]]) {\n            g1 = g1.replace(match[0], `#${idMap[match[1]]}`);\n        }\n\n        g1 = g1.replace(/^(\\s*)/, \"$1\" + prefix + \" \");\n\n        return g1 + g2;\n    });\n\n    return css;\n};","function promisifyRequest(request) {\n    return new Promise((resolve, reject) => {\n        // @ts-ignore - file size hacks\n        request.oncomplete = request.onsuccess = () => resolve(request.result);\n        // @ts-ignore - file size hacks\n        request.onabort = request.onerror = () => reject(request.error);\n    });\n}\nfunction createStore(dbName, storeName) {\n    const request = indexedDB.open(dbName);\n    request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n    const dbp = promisifyRequest(request);\n    return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));\n}\nlet defaultGetStoreFunc;\nfunction defaultGetStore() {\n    if (!defaultGetStoreFunc) {\n        defaultGetStoreFunc = createStore('keyval-store', 'keyval');\n    }\n    return defaultGetStoreFunc;\n}\n/**\n * Get a value by its key.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction get(key, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => promisifyRequest(store.get(key)));\n}\n/**\n * Set a value with a key.\n *\n * @param key\n * @param value\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction set(key, value, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.put(value, key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Set multiple values at once. This is faster than calling set() multiple times.\n * It's also atomic â€“ if one of the pairs can't be added, none will be added.\n *\n * @param entries Array of entries, where each entry is an array of `[key, value]`.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction setMany(entries, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        entries.forEach((entry) => store.put(entry[1], entry[0]));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Get multiple values by their keys\n *\n * @param keys\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction getMany(keys, customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => Promise.all(keys.map((key) => promisifyRequest(store.get(key)))));\n}\n/**\n * Update a value. This lets you see the old value and update it as an atomic operation.\n *\n * @param key\n * @param updater A callback that takes the old value and returns a new value.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction update(key, updater, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => \n    // Need to create the promise manually.\n    // If I try to chain promises, the transaction closes in browsers\n    // that use a promise polyfill (IE10/11).\n    new Promise((resolve, reject) => {\n        store.get(key).onsuccess = function () {\n            try {\n                store.put(updater(this.result), key);\n                resolve(promisifyRequest(store.transaction));\n            }\n            catch (err) {\n                reject(err);\n            }\n        };\n    }));\n}\n/**\n * Delete a particular key from the store.\n *\n * @param key\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction del(key, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.delete(key);\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Delete multiple keys at once.\n *\n * @param keys List of keys to delete.\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction delMany(keys, customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        keys.forEach((key) => store.delete(key));\n        return promisifyRequest(store.transaction);\n    });\n}\n/**\n * Clear all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction clear(customStore = defaultGetStore()) {\n    return customStore('readwrite', (store) => {\n        store.clear();\n        return promisifyRequest(store.transaction);\n    });\n}\nfunction eachCursor(store, callback) {\n    store.openCursor().onsuccess = function () {\n        if (!this.result)\n            return;\n        callback(this.result);\n        this.result.continue();\n    };\n    return promisifyRequest(store.transaction);\n}\n/**\n * Get all keys in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction keys(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAllKeys) {\n            return promisifyRequest(store.getAllKeys());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);\n    });\n}\n/**\n * Get all values in the store.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction values(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        if (store.getAll) {\n            return promisifyRequest(store.getAll());\n        }\n        const items = [];\n        return eachCursor(store, (cursor) => items.push(cursor.value)).then(() => items);\n    });\n}\n/**\n * Get all entries in the store. Each entry is an array of `[key, value]`.\n *\n * @param customStore Method to get a custom store. Use with caution (see the docs).\n */\nfunction entries(customStore = defaultGetStore()) {\n    return customStore('readonly', (store) => {\n        // Fast path for modern browsers\n        // (although, hopefully we'll get a simpler path some day)\n        if (store.getAll && store.getAllKeys) {\n            return Promise.all([\n                promisifyRequest(store.getAllKeys()),\n                promisifyRequest(store.getAll()),\n            ]).then(([keys, values]) => keys.map((key, i) => [key, values[i]]));\n        }\n        const items = [];\n        return customStore('readonly', (store) => eachCursor(store, (cursor) => items.push([cursor.key, cursor.value])).then(() => items));\n    });\n}\n\nexport { clear, createStore, del, delMany, entries, get, getMany, keys, promisifyRequest, set, setMany, update, values };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\"use strict\";\n\nconst { get, set, del, entries } = require(\"idb-keyval\");\nconst cssScope = require(\"./lib/scope-css\");\nconst cssUrlFixer = require(\"./lib/css-url-fixer\");\nconst counter = require(\"./lib/counter\");\n\nconst isCacheAvailable = async (url) => {\n    let item;\n\n    try {\n        item = await get(`loader_${url}`);\n    } catch (e) {}\n\n    if (!item) {\n        try {\n            item = localStorage.getItem(`loader_${url}`);\n        } catch(e) {}\n    }\n\n    if (!item) {\n        return;\n    }\n\n    item = JSON.parse(item);\n\n    if (Date.now() < item.expiry) {\n        return item.data;\n    } else {\n        del(`loader_${url}`);\n        return;\n    }\n};\n\nconst setCache = async (url, data, cacheOpt) => {\n    const cacheExp = parseInt(cacheOpt, 10);\n    const dataToSet =  JSON.stringify({\n        data,\n        expiry: Date.now() + (Number.isNaN(cacheExp) ? 60 * 60 * 1000 * 24 * 30 : cacheExp)\n    });\n\n    try {\n        await set(`loader_${url}`, dataToSet);\n    } catch (e) {\n        try {\n            localStorage.setItem(`loader_${url}`, dataToSet)\n        } catch (e) {\n            console.warn(\"Failed to set cache: \", e)\n        }\n    };\n};\n\nconst DOM_EVENTS = [];\nconst getAllEventNames = () => {\n    if (DOM_EVENTS.length) {\n        return DOM_EVENTS;\n    }\n\n    for (const prop in document.head) {\n        if (prop.startsWith(\"on\")) {\n            DOM_EVENTS.push(prop);\n        }\n    }\n\n    return DOM_EVENTS;\n};\n\nconst attributesSet = {};\nconst renderBody = (elem, options, body) => {\n    const { enableJs, disableUniqueIds, disableCssScoping } = options;\n\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(body, \"text/html\");\n    const fragment = doc.querySelector(\"svg\");\n\n    const eventNames = getAllEventNames();\n\n    // When svg-loader is loading in the same element, it's\n    // important to keep track of original properties.\n    const elemAttributesSet = attributesSet[elem.getAttribute(\"data-id\")] || new Set();\n\n    const elemUniqueId = elem.getAttribute(\"data-id\") || `svg-loader_${counter.incr()}`;\n\n    const idMap = {};\n\n    if (!disableUniqueIds) {\n        // Append a unique suffix for every ID so elements don't conflict.\n        Array.from(doc.querySelectorAll(\"[id]\")).forEach((elem) => {\n            const id = elem.getAttribute(\"id\");\n            const newId = `${id}_${counter.incr()}`;\n            elem.setAttribute(\"id\", newId);\n\n            idMap[id] = newId;\n        });\n    }\n\n    Array.from(doc.querySelectorAll(\"*\")).forEach((el) => {\n        // Unless explicitly set, remove JS code (default)\n        if (el.tagName === \"script\") {\n            el.remove();\n            if (!enableJs) {\n                return;\n            } else {\n                const scriptEl = document.createElement(\"script\");\n                scriptEl.appendChild(el.childNodes[0]);\n                elem.appendChild(scriptEl)\n            }\n        }\n\n        const attributesToRemove = []\n        for (let i = 0; i < el.attributes.length; i++) {\n            const {\n                name,\n                value\n            } = el.attributes[i];\n\n            const newValue = cssUrlFixer(idMap, value, name);\n\n            if (value !== newValue) {\n                el.setAttribute(name, newValue);\n            }\n\n            // Remove event functions: onmouseover, onclick ... unless specifically enabled\n            if (eventNames.includes(name.toLowerCase()) && !enableJs) {\n                attributesToRemove.push(name);\n                continue;\n            }\n\n            // Remove \"javascript:...\" unless specifically enabled\n            if ([\"href\", \"xlink:href\"].includes(name) && value.startsWith(\"javascript\") && !enableJs) {\n                attributesToRemove.push(name);\n            }\n        }\n\n        attributesToRemove.forEach((attr) => el.removeAttribute(attr))\n\n        // .first -> [data-id=\"svg_loader_341xx\"] .first\n        // Makes sure that class names don't conflict with each other.\n        if (el.tagName === \"style\" && !disableCssScoping) {\n            let newValue = cssScope(el.innerHTML, `[data-id=\"${elemUniqueId}\"]`, idMap);\n            newValue = cssUrlFixer(idMap, newValue);\n            if (newValue !== el.innerHTML)\n                el.innerHTML = newValue;\n        }\n    });\n\n    for (let i = 0; i < fragment.attributes.length; i++) {\n        const {\n            name,\n            value\n        } = fragment.attributes[i];\n\n        // Don't override the attributes already defined, but override the ones that\n        // were in the original element\n        if (!elem.getAttribute(name) || elemAttributesSet.has(name)) {\n            elemAttributesSet.add(name);\n            elem.setAttribute(name, value);\n        }\n    }\n\n    attributesSet[elemUniqueId] = elemAttributesSet;\n\n    elem.setAttribute(\"data-id\", elemUniqueId);\n    elem.innerHTML = fragment.innerHTML;\n\n    const event = new CustomEvent('iconload', {\n        bubbles: true\n    });\n    elem.dispatchEvent(event);\n\n    if (elem.getAttribute('oniconload')) {\n        // Handling (and executing) event attribute for our event (oniconload)\n        // isn't straightforward. Because a) the code is a raw string b) there's\n        // no way to specify the context for execution. So, `this` in the attribute\n        // will point to `window` instead of the element itself. \n        //\n        // Here we are recycling a rarely used GlobalEventHandler 'onloadedmetadata'\n        // and offloading the execution to the browser. This is a hack, but because\n        // the event doesn't bubble, it shouldn't affect anything else in the code. \n        elem.setAttribute('onauxclick', elem.getAttribute('oniconload'));\n        \n        const event = new CustomEvent('auxclick', {\n            bubbles: false,\n            view: window\n        });\n        elem.dispatchEvent(event);\n\n        elem.removeAttribute('onauxclick');\n    }\n};\n\nconst requestsInProgress = {};\nconst memoryCache = {};\n\nconst renderIcon = async (elem) => {\n    const src = elem.getAttribute(\"data-src\");\n    const cacheOpt = elem.getAttribute(\"data-cache\");\n\n    const enableJs = elem.getAttribute(\"data-js\") === \"enabled\";\n    const disableUniqueIds = elem.getAttribute(\"data-unique-ids\") === \"disabled\";\n    const disableCssScoping = elem.getAttribute(\"data-css-scoping\") === \"disabled\";\n\n    const lsCache = await isCacheAvailable(src);\n    const isCachingEnabled = cacheOpt !== \"disabled\";\n\n    const renderBodyCb = renderBody.bind(self, elem, { enableJs, disableUniqueIds, disableCssScoping });\n\n    // Memory cache optimizes same icon requested multiple\n    // times on the page\n    if (memoryCache[src] || (isCachingEnabled && lsCache)) {\n        const cache = memoryCache[src] || lsCache;\n\n        renderBodyCb(cache);\n    } else {\n        // If the same icon is being requested to rendered\n        // avoid firing multiple XHRs\n        if (requestsInProgress[src]) {\n            setTimeout(() => renderIcon(elem), 20);\n            return;\n        }\n\n        requestsInProgress[src] = true;\n\n        fetch(src)\n            .then((response) => {\n                if (!response.ok) {\n                    throw Error(`Request for '${src}' returned ${response.status} (${response.statusText})`);\n                }\n                return response.text();\n            })\n            .then((body) => {\n                const bodyLower = body.toLowerCase().trim();\n\n                if (!(bodyLower.startsWith(\"<svg\") || bodyLower.startsWith(\"<?xml\"))) {\n                    throw Error(`Resource '${src}' returned an invalid SVG file`);\n                }\n\n                if (isCachingEnabled) {\n                    setCache(src, body, cacheOpt);\n                }\n\n                memoryCache[src] = body;\n\n                renderBodyCb(body);\n            })\n            .catch((e) => {\n                console.error(e);\n            })\n            .finally(() => {\n                delete requestsInProgress[src];\n            });\n    }\n};\n\nlet intObserver;\nif (globalThis.IntersectionObserver) {\n    intObserver = new IntersectionObserver(\n        (entries) => {\n            entries.forEach((entry) => {\n                if (entry.isIntersecting) {\n                    renderIcon(entry.target);\n    \n                    // Unobserve as soon as soon the icon is rendered\n                    intObserver.unobserve(entry.target);\n                }\n            });\n        }, {\n            // Keep high root margin because intersection observer \n            // can be slow to react\n            rootMargin: \"1200px\"\n        }\n    );\n}\n\n\nconst handled = [];\nfunction renderAllSVGs() {\n    Array.from(document.querySelectorAll(\"svg[data-src]:not([data-id])\"))\n        .forEach((element) => {\n            if (handled.indexOf(element) !== -1) {\n                return;\n            }\n\n            handled.push(element);\n            if (element.getAttribute(\"data-loading\") === \"lazy\") {\n                intObserver.observe(element);\n            } else {\n                renderIcon(element);\n            }\n        });\n}\n\nlet observerAdded = false;\nconst addObservers = () => {\n    if (observerAdded) {\n        return;\n    }\n\n    observerAdded = true;\n    const observer = new MutationObserver((mutationRecords) => {\n        const shouldTriggerRender = mutationRecords.some(\n            (record) => Array.from(record.addedNodes).some(\n                (elem) => elem.nodeType === Node.ELEMENT_NODE\n                    && ((elem.getAttribute(\"data-src\") && !elem.getAttribute(\"data-id\")) // Check if the element needs to be rendered\n                        || elem.querySelector(\"svg[data-src]:not([data-id])\")) // Check if any of the element's children need to be rendered\n            )\n        );\n\n        // If any node is added, render all new nodes because the nodes that have already\n        // been rendered won't be rendered again.\n        if (shouldTriggerRender) {\n            renderAllSVGs();\n        }\n\n        // If data-src is changed, re-render\n        mutationRecords.forEach((record) => {\n            if (record.type === \"attributes\") {\n                renderIcon(record.target);\n            }\n        });\n    });\n\n    observer.observe(\n        document.documentElement,\n        {\n            attributeFilter: [\"data-src\"],\n            attributes: true,\n            childList: true,\n            subtree: true\n        }\n    );\n};\n\nif (globalThis.addEventListener) {\n    // Start rendering SVGs as soon as possible\n    const intervalCheck = setInterval(() => {\n        renderAllSVGs();\n    }, 100);\n\n    function init() {\n        clearInterval(intervalCheck);\n    \n        renderAllSVGs();\n        addObservers();\n    }\n\n    if (document.readyState === 'interactive') {\n        init();\n    } else {\n        globalThis.addEventListener(\"DOMContentLoaded\", () => {\n            init();\n        });\n    }\n}\n\nglobalThis.SVGLoader = {}\nglobalThis.SVGLoader.destroyCache = async () => {\n    // Handle error, \"mutation operation was attempted on a database\"\n    // with try-catch\n    try {\n        const entriesCache = await entries();\n        \n        for (const entry of entriesCache) {\n            if (entry[0].startsWith('loader_')) {\n                await del(entry[0]);\n            }\n        }\n    } catch(e) {}\n\n    Object.keys(localStorage).forEach((key) => {\n        if (key.startsWith('loader_')) {\n            localStorage.removeItem(key);\n        }\n    });\n}\n"],"names":[],"sourceRoot":""}